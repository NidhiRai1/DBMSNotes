//CLUSTER - SET OF RREPLICA SERVER IS CALLED CLUSTERING S1 = S2 = S3 (SAME USER DATA ) .
THIS IS USE FOR REDUNDENCY (REPETED DATA IN DIFFERENT SERVER ) , DUE TO HTIS IF S1 IS SHUT DOWN THEN YOUR WORK NOT STOP.

//ADCANTAGES OF CLUSTERING
*SYATEM BECOME HIGHLLY AVAILABLE , 
*ABSTRACTION LAYER CAUSED 
*LOAD BALANCING
*DATA STORAGE BECOME EASY BY DBMS 
DATA IS HUGE -> RESPOSE TIME IS HIGH -> U NEED TO APPLY DATA BASE OPTIMISATION TECHNIQUE -> MANAGABLITY EASY -> REDUCE RESPONSE TIME

//OPTIMISATION TECHNIQUE BY-
1.SCALE UP (INCREASE THE HARDWARE SIZE ) BUT DUE TO THIS COSTING ENHANCE
2.BETTER WAY IS BY REPLICA THROUGH --CLUSTERING-- BUT DUE TO THIS DELAY INCREASE BECAUSE UPDATE CAME IN MASTER SERVE
HWHICH THEN DISTRIBUTE TO OTHRER REPLICA SERVER FOR UPDATION
3. BEST WAY IS BY --PARTITIONING IS A SCALE OUT(HORIZANTAL PARTITANING) TECHNIQUE SO , WE DIVIDE THE STORE DATA IN 
DIFFERENT SERVER IN HORIZANTAL FORM (WHEN DATA BASE REQUEST IS HUGE )

*AVAILABILITY INCREASE 
*PERFORMANCE (COZ S1 AND S2 ARE LESS LOADED)
MANAGABILITY INCREASE
*COST REDUCE

//SHARDIMG - DATA ARE DIVIDE INTO S1 AND S2 DATA 
ROUTING LAYER IS NEEDED IN THIS WHICH IS USE TO LOOK UP WHERE TO GO IN S1 OR S2 FOR FURTHER DATA  
SAME ADVANTAGES AS PARTITIONING 

----DISADAVANTAGES 
*NON UNIFORMITY (HANDLE BY RE-SHARDING)
*COMPLEXITY INCREASE



 
TRABSECTION -- MUST BE

COMMIT COMMANC D- ACTUAL DATABASE KE ANDAR YE CHIZ PERFORM AFTER THIS 

//ACID PROPERTY - TO MAINTAI THE INTEGRITY IN THE DATABASE
1.ATOMIC - THEY ALL ARE CONSIDER AS ONE TASK WHICH IS SUCCESSFULLLY OR UNSUCCESSESFUL (0/1) AND ROLLBACK TO OLD STATE IF UNSESSUSSFUL .
2.CONSISTENCY - INTEGRITY CONSTRAIN SHOULD BE MAINTAIN BEFORE AND AFTER THE TRANSECTION
3.ISOLATION - LET TRANSCTION FROM PHONEPAY AND PAYTM BOTH THEN ARE DONE SEQUENTAL FIRST OCCUR ONE THEN SECOND .
4.DURABALITY -AFTER TRANSECTION SUCCESS THEN  CHANGES ARE PERSISTANCE (PARAMANET) EVEN THEIR IS A SYSTEM FALIUR .

STATE OF TRANSECTION (LIFE TRANSECTION)
ACTIVE STATE - 


ACTIVE STATE - HERE READ WRITE OPERATION STATE DONE 
PARTIALLY COMMITTED STATE - 
COMMITED STATE - DB CAN ENTER TO 2ND STATE MEANS THEIR IS PARAMANEET CHANGES NO ROLLBACK .
TERMINATE STATE -
FAIL STATE - DUE TO SOME FALIUR THEIR IS NO TRANSECTION OSSIBLE 
ABOILT STTAE - ALL THE CHANGES IN BUFFER GOT REVERSE TO 1ST STAE 

//HOW TO implement ACID

SHADOW COPY scheme we can able to maintain ATOMECITY AND DUREBILITY 
THIS IS INEFFICIENT COZ COPING BIG DATA IN TERABIT IS NOT A GOOD WAY TOOK LOTS OF SPACE.

LOG BASED RECOVERY SYSTEM - WITH EVERY TRANSECTION YOU WERE GENERATING LOGS WHICH IS STORED IN SOME STABLE 
STORAGR NOT AT THE PLACE WERE DB IS STORED THEN WITH DB FALIUR LOG ALSO GOT LOST
AN DTHE STORAGE OF LOG IS DONE BEFORE THE ACTUAL TRANJECTION HAPPEN

DEFERED DB MODIFICATION - ENSURING ATOMICITY BY MODIFING ALL THE DB MODIFICATION IN LOG BUT
DEFERING EXECUTION OF  WRITE OPERATION UNTIL FINAL TRANSETION HAPPENS ,
*IF THE SYSTEM GOT CRASHED BEFORE THE TRANJECTION COMPLETED THEN IGONRE WHAT IN THE LOG
*IF THE FALIUR OCCUR WHILE THE UPDATION THEN PERFORM REDO

IMMEDIATE DB MODIFICATION - LOG (FIRSTKY THIS )AND DB MODIFIACTION THROUGH WRITE OPERATION HAPPEN TOGETHRER IN THE  ACTIVE STATE.
*IN CASE OF TRANSECTION FALIUR 

chech point recovery method






//performance optimisation technique in dbms 
disc me block me chize store hoti h

*INDEXING - ENHANCE THE PERFORMANCE BY INC. THE ACCESSING SPEED OF DB BY DECREASING THE ACCESS IN THE DISC
*SEARCH KEY - IT IS YOU TO FIND THE INDEXING AND GET THE RESULT  , IT CAN BE PK , FK CK

//TYPE OF INDEXING 
1.PRIMARY INDEXING (CLUSTRING INDEXING) - APPLIED WHERE THE KEY IN SEQUENCELLY SORTED

//TYPES OF PRIMARY INDEXING
--DENSE INDEX -ALL THE SEARCH FILE ARE INCLUDED IN THE INDEX TABLE/FILE ,THEY ARE SORTTED
ON THE BASIS OF NON - KEY ATTRIBUTE FILE IS SORTED AND THEY ARE REPETING (LIKE NAME  PEOPLE HAVE SAME NAME )


---SPARSE INDEX - INDEX APPER FOE SOME OF THE SEARCH KEY . 
INDEXING ON THE BASIS OF KEY ATTRIBUTE( PRIMERY KEY  OR  CANDED KEY )THEN 
THINGS ARE SORTED NO NEED TO ADD ALL SELECT FILE THEN USE SPARSE INDEXING THAT'S BETTER
* NO. OF ENTRIES IN THE INDEX FILE = NO. OF BLOCKS IN DATAFILE

---MULTI-LEVEL INDEXING - IT IS ALSO SORTTED INDEX KE UPAR FURTHER INDEXING KRNA IS MULTI LEVEL 

2.SECONDARY INDEX - WHEN THE DATA FILE IN UNSORTED 
